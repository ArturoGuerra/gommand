// Code generated by gommand. DO NOT EDIT.
package gommand

import (
	"context"
	"github.com/andersfylling/disgord"
	"time"
)

// WaitManager is used to manage waiting within the context.
type WaitManager struct {
    ctx *Context
}

// This allows you to wait for a event with specific conditions. You should NOT block during the check function.
func (w *WaitManager) waitForEvent(ctx context.Context, EventName string, CheckFunc func(s disgord.Session, evt interface{}) bool) interface{} {
	x := make(chan interface{})
	middleware := func(evt interface{}) interface{} {
		if !CheckFunc(w.ctx.Session, evt) {
			return nil
		}
		return evt
	}
	var timer *time.Timer
	until, ok := ctx.Deadline()
	if ok {
		timer = time.AfterFunc(time.Until(until), func() {
			x <- nil
		})
	}
	handleEmit := func(e interface{}) {
		x <- e
		if timer != nil {
			timer.Stop()
		}
	}
	var emitChan interface{}
	switch EventName {
	{{ range . }}case disgord.Evt{{ . }}:
		emitChan = func(_ disgord.Session, e *disgord.{{ . }}) { handleEmit(e) }
	{{ end }}default:
		panic("unknown event")
	}
	w.ctx.Session.On(EventName, middleware, emitChan, &disgord.Ctrl{Runs: 1, Until: until})
	return <-x
}
{{ range . }}
// WaitFor{{ . }} allows you to wait for the {{ . }} event. You should NOT block during the check function.
func (w *WaitManager) WaitFor{{ . }}(ctx context.Context, CheckFunc func(s disgord.Session, evt *disgord.{{ . }}) bool) *disgord.{{ . }} {
	x := w.waitForEvent(ctx, disgord.Evt{{ . }}, func(s disgord.Session, evt interface{}) bool {
		if e, ok := evt.(*disgord.{{ . }}); ok {
			return CheckFunc(s, e)
		}
		return false
	})
	r, ok := x.(*disgord.{{ . }})
	if !ok {
	    return nil
	}
	return r
}
{{ end }}